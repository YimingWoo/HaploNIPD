#'@title parse_GT
#'@description Parse GT information of sentieon VCF data
parse_GT <- function(gtinfo) {
  data.table::tstrsplit(gtinfo, "[:,]", keep = 1:4)
  #, type.convert = list(as.numeric = 3:4))
}

#'@title parse_Mutect2_GT
#'@description Parse GT information of VCF data generated by Mutect2/TNhaplotyper2
parse_Mutect2_GT <- function(gtinfo) {
  data.table::tstrsplit(gtinfo, "[:,]", keep = c(1, 2, 3, 5))
}

#'@title parse_Mutect2_vcf
#'@description Parse VCF information generated by Mutect2/TNhaplotyper2
parse_Mutect2_vcf <- function(vcfdat, change_name = FALSE) {
  # fix part of vcf
  vcfret <- vcfdat[, c(1:5, 10)]
  colnames(vcfret)[1:5] <-
    c("chrom", "pos", "varid", "ref", "alt")

  sampname <-
    ifelse(change_name == TRUE, "cfdna", names(vcfret)[6])
  vcfret[, paste(rep(sampname, each = 4),
                 c("genotype", "ref_dp", "alt_dp", "total_dp"),
                 sep = "_")
         := sapply(.SD, parse_Mutect2_GT), .SDcols = 6][, names(vcfret)[6] := NULL]
  dpinfo_names <- grep("dp$", names(vcfret), value = T)
  vcfret <-
    cbind(vcfret[,!..dpinfo_names], vcfret[, lapply(.SD, as.integer), .SDcols =
                                             dpinfo_names])

  return(vcfret)
}

#'@title parse_family_vcf
#'@description Parse family-based VCF data into data table format
parse_family_vcf <- function(vcfdat,
                             pedigree_dat,
                             roi = NULL,
                             mincov_cf = 100,
                             mincov = 30,
                             cfvcf_dir = NULL,
                             RAHP_mode = TRUE) {
  # process pedigree information
  pedinfo <- pedtools::as.ped(pedigree_dat[, 1:5])
  family_members <- pedinfo$ID
  # in case fake family members made up to fill up pedigree
  real_family_members <-
    intersect(family_members, colnames(vcfdat))

  # process variant information
  vcf_posinfo <- vcfdat[, c(1, 2, 3, 4, 5)]
  colnames(vcf_posinfo) <-
    c("chrom", "pos", "varid", "ref", "alt")
  vcf_gtinfo <- vcfdat[, real_family_members, with = F]
  if (length(vcf_gtinfo) == 0) {
    stop(paste("Something wrong with family ", pedtools::leaves(pedinfo)[1], sep = " "))
  }
  fam_genodat <- list(pedigree = pedinfo)

  if (RAHP_mode == FALSE) {
    # no relatives in pedigree
    offsprings <- pedtools::leaves(pedinfo)
    cfdna <- grep(offsprings,
                  pattern = "(CF)|(cf)",
                  value = T)
    if (length(cfdna) == 0) {
      stop(paste("Something wrong with family ", pedtools::leaves(pedinfo)[1], sep = " "))
    }
    fam_genodat$sampmode <- "wo_probands"
    fam_genodat$sampname <- cfdna
    fam_genodat$has_mom_geno <- TRUE

    data.table::setnames(
      vcf_gtinfo,
      old = c(cfdna, pedtools::father(pedinfo, cfdna), pedtools::mother(pedinfo, cfdna)),
      new = c("cfdna", "father", "mother")
    )
  }
  else if (length(family_members) < 5) {
    # has proband in pedigree
    fam_genodat$sampmode <- "PAHP"
    offsprings <- pedtools::leaves(pedinfo)
    if (length(offsprings) > 2) {
      stop(paste("Incorrect setting of family ", pedtools::leaves(pedinfo)[1], sep = " "))
    } else if (length(offsprings) == 1) {
      # trios with proband (mother genotype inferred from cfDNA)
      proband <- offsprings
      cfdna <- pedtools::mother(pedinfo, proband)
      fam_genodat$sampname <- cfdna
      fam_genodat$has_mom_geno <- FALSE

      data.table::setnames(
        vcf_gtinfo,
        old = c(
          pedtools::leaves(pedinfo),
          pedtools::father(pedinfo, proband),
          pedtools::mother(pedinfo, proband)
        ),
        new = c("proband", "father", "cfdna")
      )
    } else if (length(offsprings) == 2) {
      # trios with proband (mother genotyped other than only cfDNA)
      cfdna_ind <- grep(offsprings, pattern = "(CF)|(cf)")
      proband_ind <- 3 - cfdna_ind
      proband <- offsprings[proband_ind]
      cfdna <- offsprings[cfdna_ind]
      fam_genodat$sampname <- cfdna
      fam_genodat$has_mom_geno <- TRUE

      data.table::setnames(
        vcf_gtinfo,
        old = c(
          proband,
          cfdna,
          pedtools::father(pedinfo, proband),
          pedtools::mother(pedinfo, proband)
        ),
        new = c("proband", "cfdna", "father", "mother")
      )
    }
  }
  else {
    # has grandparent(s) in pedigree
    fam_genodat$sampmode <- "GAHP"
    offsprings <- pedtools::leaves(pedinfo)
    if (length(offsprings) != 1) {
      stop(paste(
        "Incorrect offspring setting in family ",
        pedtools::leaves(pedinfo)[1],
        sep = " "
      ))
    }

    if (offsprings %in% real_family_members) {
      # cfdna as descendants
      cfdna <- offsprings
      fam_genodat$sampname <- cfdna
      fam_genodat$has_mom_geno <- TRUE
      data.table::setnames(
        vcf_gtinfo,
        old = c(cfdna, pedtools::father(pedinfo, cfdna), pedtools::mother(pedinfo, cfdna)),
        new = c("cfdna", "father", "mother")
      )
    } else {
      # mock descendants
      cfdna <- pedtools::mother(pedinfo, offsprings)
      fam_genodat$sampname <- cfdna
      fam_genodat$has_mom_geno <- FALSE
      data.table::setnames(
        vcf_gtinfo,
        old = c(
          pedtools::father(pedinfo, offsprings),
          pedtools::mother(pedinfo, offsprings)
        ),
        new = c("father", "cfdna")
      )
    }

    index_grandparents <- c()
    index_members <- pedigree_dat[index == 1]$id

    father_id <- pedtools::father(pedinfo, offsprings)
    if (length(pedtools::parents(pedinfo, father_id)) > 0) {
      # has grandparent(s) on father's side
      grandpa_pat <- pedtools::father(pedinfo, father_id)
      grandma_pat <- pedtools::mother(pedinfo, father_id)

      if (grandpa_pat %in% real_family_members) {
        fam_genodat$pat_grandpa <- TRUE
        data.table::setnames(vcf_gtinfo,
                 old = c(grandpa_pat),
                 new = c("grandpa_pat"))
        if (grandpa_pat %in% index_members) {
          index_grandparents <- c(index_grandparents, "pat_grandpa")
        }
      }
      if (grandma_pat %in% real_family_members) {
        fam_genodat$pat_grandma <- TRUE
        data.table::setnames(vcf_gtinfo,
                 old = c(grandma_pat),
                 new = c("grandma_pat"))
        if (grandma_pat %in% index_members) {
          index_grandparents <- c(index_grandparents, 'pat_grandma')
        }
      }
    }

    mother_id <-
      ifelse(fam_genodat$has_mom_geno == TRUE,
             pedtools::mother(pedinfo, cfdna),
             cfdna)
    if (length(pedtools::parents(pedinfo, mother_id)) > 0) {
      # has grandparent(s) on mother's side
      grandpa_mat <- pedtools::father(pedinfo, mother_id)
      grandma_mat <- pedtools::mother(pedinfo, mother_id)

      if (grandpa_mat %in% real_family_members) {
        fam_genodat$mat_grandpa <- TRUE
        data.table::setnames(vcf_gtinfo,
                 old = c(grandpa_mat),
                 new = c("grandpa_mat"))
        if (grandpa_mat %in% index_members) {
          index_grandparents <- c(index_grandparents, 'mat_grandpa')
        }
      }
      if (grandma_mat %in% real_family_members) {
        fam_genodat$mat_grandma <- TRUE
        data.table::setnames(vcf_gtinfo,
                 old = c(grandma_mat),
                 new = c("grandma_mat"))
        if (grandma_mat %in% index_members) {
          index_grandparents <- c(index_grandparents, 'mat_grandma')
        }
      }
    }


    # check if number of indexed parents equals to the necessary count
    need_indexed = 0
    if (length(pedtools::parents(pedinfo, father_id)) == 2)
      need_indexed = need_indexed + 1
    if (length(pedtools::parents(pedinfo, mother_id)) == 2)
      need_indexed = need_indexed + 1
    if (length(index_grandparents) != need_indexed) {
      stop(paste(
        "Incorrect index grandparents recorded in family ",
        pedtools::leaves(pedinfo)[1],
        sep = " "
      ))
    }

    fam_genodat$index_grandparents <- index_grandparents
  }


  vcf_gtinfo[, paste(rep(names(vcf_gtinfo), each = 4),
                     c("genotype", "ref_dp", "alt_dp", "total_dp"),
                     sep = "_") := sapply(.SD, parse_GT)][,
                                                          names(vcf_gtinfo)[seq_along(real_family_members)] := NULL]
  dpinfo_names <- grep("dp$", names(vcf_gtinfo), value = T)
  vcf_gtinfo <- cbind(vcf_gtinfo[, !..dpinfo_names],
                       vcf_gtinfo[, lapply(.SD, as.integer), .SDcols = dpinfo_names])
  vcfret <- cbind(vcf_posinfo, vcf_gtinfo)

  # check if cfdna variant VCF generated by mutect2/TNhaplotyper2 exists
  cfvcf_flt <-
    paste0(cfvcf_dir, "/", fam_genodat$sampname, ".flt.vcf.gz")
  cfvcf_raw <-
    paste0(cfvcf_dir, "/", fam_genodat$sampname, ".raw.vcf.gz")
  if (file.exists(cfvcf_flt)) {
    vcfret <- replace_cf(cfvcf_flt, vcfret)
  } else if (file.exists(cfvcf_raw)) {
    vcfret <- replace_cf(cfvcf_raw, vcfret)
  }

  # depth filter
  vcfret <-
    vcfret[cfdna_total_dp >= mincov_cf & cfdna_genotype != "./."]
  dpcols <- grep("total_dp$", colnames(vcfret), value = TRUE)
  vcfret[, dp_pass := apply(.SD, 1, function(x)
    all(x > mincov)), .SDcols = dpcols]
  vcfret <- vcfret[dp_pass == TRUE][, dp_pass := NULL]

  fam_genodat$vcfdat = vcfret

  if (!is.null(roi) & length(roi) > 0) {
    roi <- gsub(roi, pattern = "-", replacement = ":")
    roi_info <- data.table::rbindlist(lapply(roi, data.table::tstrsplit, split = ":"))
    # need to modify for chrN only
    colnames(roi_info) <- c("chrom", "start", "end")
    roi_info[, ':=' (start = as.integer(start), end = as.integer(end))]

    chrom_start <- sapply(roi_info$chrom, function(chrN) {
      utils::head(genetic_mapinfo[chrom == chrN], 1)$pos
    })
    chrom_end <- sapply(roi_info$chrom, function(chrN) {
      utils::tail(genetic_mapinfo[chrom == chrN], 1)$pos
    })
    roi_info[, startpos := pmax(chrom_start, start - 4e6)][,
      endpos := pmin(chrom_end, end + 4e6)]
    fam_genodat$roi_info <- roi_info
  }
  return(fam_genodat)
}

#'@title replace_cf
#'@description replace cfdna variants depth information
replace_cf <- function(cfvcf, vcfdat) {
  cfvcf_dat <- data.table::fread(cfvcf, skip = "#CHROM")
  cfvcf_dat <- cfvcf_dat[FILTER %in% c(".", "PASS")]
  cfvcf_info <- parse_Mutect2_vcf(cfvcf_dat, change_name = TRUE)
  cfvcf_info[, chromPos := paste(chrom, pos, sep = ":")]
  cfvcf_info <-
    cfvcf_info[, c("chromPos", grep("dp$", names(cfvcf_info), value = T)), with = F]

  vcfdat[, chromPos := paste(chrom, pos, sep = ":")]
  cfvcf_info <- cfvcf_info[chromPos %in% vcfdat$chromPos]
  vcfdat_uniq <- vcfdat[!chromPos %in% cfvcf_info$chromPos]
  vcfdat_shared <- vcfdat[chromPos %in% cfvcf_info$chromPos]
  vcfdat_shared[, ':=' (
    cfdna_ref_dp = cfvcf_info$cfdna_ref_dp,
    cfdna_alt_dp = cfvcf_info$cfdna_alt_dp,
    cfdna_total_dp = cfvcf_info$cfdna_total_dp
  )]
  vcfdat <- rbind(vcfdat_uniq, vcfdat_shared)
  vcfdat <- vcfdat[order(chrom, pos)][, chromPos := NULL]

  return(vcfdat)
}
